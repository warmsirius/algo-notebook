# 4. 随机快速排序

## 4.1 基本思想

快速排序使用分治的思想，通过一趟排序将待排序列分割成3部分:
* 一部分记录 > 基准
* 一部分记录 = 基准
* 一部分记录 < 基准

之后分别对 大于关键字部分 和 小于关键字部分 继续进行排序，以达到整个序列有序的目的。

### 三个步骤：

* 1.选择基准`O(1)`: 在待排序列中，按照某种方式挑出一个元素，作为 "基准"（pivot）
* 2.分割操作`O(N)`: 以该基准在序列中的实际位置，把序列分成两个子序列。
> 此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大
* 3.递归地对两个序列进行快速排序 `2T(2/N)`: 直到序列为空或者只有一个元素


### 选择基准方式: 随机选择

随机从 l-r 中选择一个位置m，和r位置的数字进行互换，引入 less、more 

* 小于基准值区域(`arr[l(原始), less]`)
* 基准值区域(`arr[less+1, more]`)
* 大于基准值区域(`arr[more, r]`)

> * `less` 指针: l-1 开始，表示小于部分，最开始是从`l-1`开始
> * `more` 指针: r 就是 more 指针的开始，因为在 partition 之前，已经进行了 `l` 和 `r` 的交换，`[l, more]` 表示大于的`arr[l]`部分
> * `l` 指针: 划分范围的最左边界
> * `r` 指针: 划分范围的最右边界

通过比较 `arr[l]` 和 `arr[r]` 的值，调整 `less`、`more` 指针步骤如下:

* 当 `arr[l]` < `arr[r]`时:
    * `less++`: less范围应该扩大1
    * `swap(less, l)`: less扩大的值，应该是当前的l位置的值
    * `l++`: l指针继续向前移动1位

* 当 `arr[l]` > `arr[r]`时:
    * `more--`: more范围扩大1位
    * `swap(arr[l], arr[more])`: more扩大的值，应该是当前l位置的值
    * `l` 保持不变: 继续比较交换后的l的值和基准值

* 当 `arr[l]` = `arr[more]`时:
    * `l++`: 等于基准值的范围 less-l增大1位

* 当 l = more时候，循环停止:
  * more 和 r 进行互换，这样大于区域、等于区域，就完全列出来了


## 4.2 快速排序细节

* 时间复杂度: `O(N*lgN)`
* 空间复杂度: `O(lgN)`
* 不具有稳定性

> 例如: 基准是3，数组是[5, 5, 5, 3]，经历过排序后，第1个5在最后面，第三个5在最前面，所以无法保证稳定的，两个相同的数字，前面的可能会跑到后面去。

平均情况:

T(N) = O(1) + O(N) + 2T(N/2)

T(N) = N*lgN


## 4.3 编程语言中排序

在Java 1.x(记不清哪个版本了):
* 当 array.length > 60时，使用的是快排
* 当 array.length < 60时，使用的是插入排序(虽然复杂度高，但是数据量小的时候，常数项很低)

## 4.4 额外问题

**问: 不使用额外数组，只用有限几个变量，能否将一个数组的奇数按照原来顺序放在左边，偶数放在右边?**

> 答: 不可以。因为快排也做不到稳定性排序，所以这道题也不太会做到。
