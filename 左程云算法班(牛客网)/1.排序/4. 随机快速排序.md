# 4. 随机快速排序

## 4.1 基本思想

快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。

### 三个步骤：

* 1.选择基准`O(1)`: 在待排序列中，按照某种方式挑出一个元素，作为 "基准"（pivot）
* 2.分割操作`O(N)`: 以该基准在序列中的实际位置，把序列分成两个子序列。

> 此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大

* 3.递归地对两个序列进行快速排序 `2T(2/N)`: 直到序列为空或者只有一个元素

### 选择基准方式: 随机选择

随机从 l-r 中选择一个位置m，和r位置的数字进行互换，引入 less、more指针，l指针进行滑动，通过比较 `arr[l]` 和 `arr[r]`(即`arr[m]`基准值)，进行 less、more指针调整，然后划分出3个区域:

* 小于基准值区域(`arr[l(原始), less]`)
* 基准值区域(`arr[less+1, more]`)
* 大于基准值区域(`arr[more, r]`)

> * `less` 指针: `l-1`，表示小于部分，最开始是从`l-1`开始
> * `more` 指针: `r` 就是 `more` 指针的开始，因为在 partition 之前，已经进行了 `l` 和 `r` 的交换，`[l, more]` 表示大于的`arr[l]`部分
> * `l` 指针: 划分范围的最左边界
> * `r` 指针: 划分范围的最右边界

通过比较 `arr[l]` 和 `arr[r]` 的值，调整 `less`、`more` 指针步骤如下:

* 当 `arr[l]` < `arr[r]`时:
    * `less++`: less范围应该扩大1
    * `swap(less, l)`: less扩大的值，应该是当前的l位置的值
    * `l++`: l指针继续向前移动1位

* 当 `arr[l]` > `arr[r]`时:
    * `more--`: more范围扩大1位
    * `swap(arr[l], arr[more])`: more扩大的值，应该是当前l位置的值
    * `l` 保持不变: 继续比较交换后的l的值和基准值

* 当 `arr[l]` = `arr[more]`时:
    * `l++`: 等于基准值的范围 less-l增大1位


## 4.2 快速排序细节

* 时间复杂度: `O(N*lgN)`
* 空间复杂度: `O(lgN)`
* 不具有稳定性

> 例如: 基准是3，数组是[5, 5, 5, 3]，经历过排序后，第1个5在最后面，第三个5在最前面，所以无法保证稳定的，两个相同的数字，前面的可能会跑到后面去。

平均情况:

T(N) = O(1) + O(N) + 2T(N/2)

T(N) = N*lgN


## 4.3 面试题

1.荷兰国旗问题

2.不使用额外数组，只用有限几个变量，能否将一个数组的奇数放在左边，偶数放在右边

> 答: 不可以。因为快排也做不到稳定性排序，所以这道题也不太会做到。

