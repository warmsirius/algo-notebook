# 2. 哈希表

## 2.1 经典哈希表
要求:
* 1.输入域无穷大，输出域有限
> 输入域无穷大的意思，并不是输入是无穷大的，是指可以输入很多值。
* 2.输入参数一旦确定，返回值一定一样(非随机函数)
* 3.所有的输入值几乎是均匀摊在整个S(值域)上


## 2.2 一致性哈希
### 经典缓存结构
简单实现负载均衡:
任何一个字符串，进行哈希计算后，值 模 3，得到的值可能是，0 1 2:
* 0-->机器1
* 1--> 机器2
* 2-->机器3

缺点: 数据迁移的代价比较高，比如加机器，减机器，所以引入了一致性哈希。


### 一致性哈希(非常重要)

假设有个环，0~2^128次方

3台机器:
* 1: ip/mac host
* 2: ip/mac host
* 3: ip/mac host

将机器的某个信息去生成1个哈希值，认为这个哈希值代表这个机器。

在环上标记起来，然后输入值 zuo，根据计算得到哈希值，在环上，然后顺时针找到第1个离它最近的机器。

如果加入m4，只需要将m3到m3这段迁移到m4

**问: 如何将加入的值，找到应该存的机器？**
> 答: 根据二分法，找到第一个比她大的值(其实我感觉有点单调栈的感觉)。


但是有个缺点， 就是不均匀分布了。
* 1.就是机器少，机器哈希值不均匀
* 2.加入的机器，也容器导致不均匀


#### 虚拟节点技术
m1、m2、m3，但是不用这个机器值计算哈希表，而是维护1张路由表。

* m1: v1-1 v1-2 v1-3...v1-1000
* m2: v2-1 v2-2 v2-3...v2-1000
* m3: v3-1 v3-2 v3-3...v3-1000

这样，m1、m2、m3都可均分环。

如果新增入 m4，m4也分配1000个虚拟节点，然后从m1 m2 m3迁移部分数据，这样达到了4个均分。



如果某个虚拟机节点计算出来重复，发生了哈希碰撞，可以将虚拟节点的专属信息改一下。


哈希表，是1个数组，可以把数组的1个个位置当做1个桶，数组中的每个元素连着1个链表

如果后面的查询操作时间复杂度变高了，不再是 O(1)的操作，就将hash表扩容。

算法环节，哈希表增删改查的时间复杂度均为 O(1)


`注意`: 不要在迭代器中删除元素，删除元素，迭代器就失效了，会报错。

> 方案: 先生成1个数组，数组里存放需要删除的元素，然后遍历数组，一个一个删除哈希表的值。

> 问: 迭代器删除过程中为什么会失效？
> 
> 答: 。



