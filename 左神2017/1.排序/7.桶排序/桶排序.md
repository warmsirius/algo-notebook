# 7. 桶排序

一般认为，基于比较的排序，时间复杂度不低于: O(N*lgN)

## 7.0 比较器

```java
Array.sort(int[] arr)
```

* 如果arr是整型的，那么使用快排
* 如果arr里面是对象/实例，那么使用的是归并排序。

> 原因: 稳定性，基础类型对稳定性没那么看重。


## 7.1 桶排序思路

**思想: 划分多个范围相同的区间，每个子区间自排序，最后合并。**

桶排序是计数排序的扩展版本，计数排序可以看成每个桶只存储相同元素，而桶排序每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。

桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序失效。


## 7.2 桶排序分析
### 时间复杂度：O(N+C)
对于待排序序列大小为 N，共分为 M 个桶，主要步骤有：

* N 次循环，将每个元素装入对应的桶中
* M 次循环，对每个桶中的数据进行排序（平均每个桶有 N/M 个元素）

一般使用较为快速的排序算法，时间复杂度为 O (N\*lgN)、O(N\*lgN) O(N*lgN)，实际的桶排序过程是以链表形式插入的。

整个桶排序的时间复杂度为：

```
O(N) + O(M*(N/M * lg(N/M))) = O(N*(lg(N/M)+1))
```

当 N = M 时，复杂度为: O(N)

### 额外空间复杂度：O(N+M)

| 分析维度 | 分析结果 |
|----|----|
| 平均时间复杂度 | `O(N * lg(N/M))` |
| 额外空间复杂度 | `O(N+M)` |
| 是否稳定 | 取决于桶内排序使用的算法 |


### 注意
* 1.桶排序的扩展: 排序后的最大相邻数差值问题
* 2.非基于比较的排序，对数据的位数和范围有限制

