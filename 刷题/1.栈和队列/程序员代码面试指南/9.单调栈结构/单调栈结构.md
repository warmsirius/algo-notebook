# 9. 单调栈结构

## 题目
给定1个不含有重复值的数组 arr，找到每1个 i位置左边 和 右边 离i最近且值比 arr[i] 小的位置。

返回所有位置相应的信息。


举例:
```text
arr = [3, 4, 1, 5, 2, 6, 7]
```

返回如下二维数组作为结果:

```text
{
 {-1, 2},
 {0, 2},
 {-1, -1},
 {2, 5},
 {3, 5},
 {2, -1},
 {5, -1},
}
```

* -1: 不存在


## 要求
时间复杂度: O(N)。


## 解题思路: 无重复值的数组
准备一个栈，记为 `stack<Integer>`，栈中放的元素是数组的位置，开始时 stack 为空。

**如果找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i]小的位置**
> 那么需要让 stack 从栈顶到栈底的位置所代表的值是严格递减的

**如果找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i]大的位置**
> 那么需要让 stack 从栈顶到栈底的位置所代表的值是严格递增的。


### 主要思路
### 压入栈
* case 1: 压入的元素 > 栈顶元素: 不破坏栈的严格递减结构
* case 2: 空栈

### 弹出栈
* 栈顶元素 > 压入元素时，弹出栈顶元素

> 弹出元素设为Y 、 压入元素设置X 、新栈顶元素设为Z
>
> 由于单调栈特性，压入元素X就是Y的右边第一个比Y小的元素，新的栈顶元素Z就是Y左边第1个比Y小的元素。

### 清算剩余的栈

stack中剩余的还未弹出的元素，依次逐个弹出。

右边第1个比Y小的元素没有，左边比Y小的元素，就是弹出后的新的栈顶元素。


## 进阶题目
给定1个可能含有重复值得数组 arr，找到每1个i位置左边 和 右边 离i最近且值比 arr[i] 小的位置。

返回所有位置相应的信息。


## 解题思路: 有重复值的数组
对于重复数组，stack存放的元素应该是1个个数组，而不应该是一个个元素了。

