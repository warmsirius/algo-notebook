# 8. 构造数组的MaxTree

## 题目

定义二叉树节点如下:
```java
public class Node{
    public int value;
    public Node left;
    public Node right;
    
    public Node(int data){
        this.value = data;
    }
}
```

1个数组的MaxTree定义如下:
* 数组内没有重复元素
* MaxTree是1棵二叉树，数组的每一个值对应1个二叉树节点
* 包括MaxTree树在内的每1棵子树上，只最大的节点都是树头

给定1个没有重复元素的数组 arr，写出生成这个数组的 MaxTree的函数。


## 难度
三颗星


## 要求
如果数组长度为N:
* 时间复杂度: O(N)
* 额外空间复杂度: O(N)


## 解题思路

下面举例说明，如何在满足时间复杂度和空间复杂度的要求下生成 MaxTree:

```
arr = [3, 4, 5, 1, 2]
```

3的左边第1个比3大的数: 无   3的右边第1个比3大的数: 4

4的左边第1个比4大的数: 无   4的右边第1个比4大的数: 5

5的左边第1个比5大的数: 无   5的右边第1个比5大的数: 无

1的左边第1个比1大的数: 5   1的右边第1个比1大的数: 2

2的左边第1个比2大的数: 5   2的右边第1个比2大的数: 无


### 建立原则
* 1.每一个数的父节点是它左边第1个比它大的数 和 它右边第1个比它大的数中，较小的那个
* 2.如果1个数左边没有比它大的数，右边也没有。那么这个数是整个数组的最大值，是MaxTree的头节点

那么，3, 4, 5, 1, 2 的 MaxTree如下:
```
      5
    /  \
   4    2
  /    /
 3    1 
```

### 证明
为什么通过这个方法能够正确生成 MaxTree 呢？

证明如下:
* 1.通过这个方法，所有的数能生成1棵树，这棵树可能不是二叉树，单肯定是一棵树，而不是多棵树(森林)

> 我们知道，在数组中的所有数都不同，而一个较小的数肯定会以一个比自己大的数作为父节点，那么最终所有的数向上都会找到数组的最大值，所以他们会有一个共同的头，证明完毕。

* 2.通过这个方法，所有的数最多都只有两个孩子。即，这棵树可以用二叉树表示。

> 要证明这个问题，只需要证明任何一个数在单独一侧，孩子数量都不可能超过1个即可。
> 
> 假设 a 这个数在单独一侧有2个孩子，不妨设在右侧。假设这2个孩子1个是k1，一个是k2，即
> 
> a...k1...k2...
> 
> 因为，a是k1和k2的父，所以 a > k1， a > k2。根据题意，k1 和 k2不相等，所以 k2和k2可以分出大小，先假设 k1 < k2
> 
> 那么 k1 可能会以 k2 为父节点，而绝对不会以 a 为父节点，因为，每一个数的父节点是它左边第一个比它大的数和右边比它大的数中较小的那个数，又 a > k2。
> 
> 同样，可证明当 k1 > k2时，k2 会以 k1为父节点，而绝对不会以 a 为父节点。
>
> 总之，k1 和 k2 肯定有1个不是 a 的孩子。


### 如何快速找到每一个数左右两边第一个比它大的数呢？
**答案: 单调栈。**


