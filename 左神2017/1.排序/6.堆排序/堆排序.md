# 6. 堆排序

## 6.1 堆排序思路
堆在逻辑上，是一棵完全二叉树。

> 堆排序是一种选择排序，整体主要由 构建初始堆+交换堆顶元素和末尾元素 并 重建堆 两部分组成。
>
> `注意`: 一轮排序从堆开始到堆结束: 建堆-＞交换-＞调整。


### 基本思想
* 1.将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。
* 2.将其与末尾元素进行交换，此时末尾就为最大值。
* 3.然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。
* 4.如此反复执行，便能得到一个有序序列了


### 关键步骤
* `heapInsert`: 构造大根堆
* `heapify`: 将堆顶元素与末尾元素进行交换，使末尾元素最大，调整剩下的堆，使最大的元素放到0的位置。
* 堆的扩大和缩小操作

将数组 => 二叉树

>下标为 i 的元素:
>* 左子节点: 2i+1
>* 右子节点: 2i+2
>* 父节点: (i-1)/2

### 大顶堆
任何一个节点，都是以该节点为顶的子树最大的值

### 小顶堆
任何一个节点，都是以该节点为顶的子树最小的值


## 6.2 堆排序分析
| 分析维度 | 分析结果 |
|----|----|
| 平均时间复杂度 | `O(N*lgN)` |
| 最优时间复杂度 | `O(N*lgN)` |
| 最坏时间复杂度 | `O(N*lgN)` |
| 额外空间复杂度 | `O(1)` |
| 是否稳定 | 否 |

### 注意
* 1.堆排序中，建立堆的操作: O(N)

```text
lg1 + lg2 + lg3 + ... + lg(n-1) + lgn = O(nlgn)
```

* 2.堆排序的核心操作: 堆，也可以说是优先级队列